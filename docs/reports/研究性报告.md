# 实验目的和意义

## 领域背景

## 存在问题

## 选题目标

# 系统需求

## 总体目标

## 系统需求

### 界面设计

### 前端
#### 展示模块
我们采用面对对象编程思想，将前端信息浏览模块总体分为两块，一块负责查询，通过抽象类函数封装对应查询目标的字符串名称。另一块负责前端显示，通过swtich语句来判断显示数据的类型实现跳转，返回给前端对应标签，以此来达到对于不同类型数据显示效果不同的结果。核心思想是
高内聚 ，低耦合，减少代码的复用率，方便代码的编写。
### 后端

# 实现方案

## 相关技术

## 总体架构

# 详细设计

## 主要模块的实现方法

### 前端的具体实现

### 后端的整体实现

### 访问中间件的具体实现

### 鉴权服务的具体实现

### 算法服务的具体实现


# 重难点问题的描述与具体实现

## 访问中间件的schema生成

访问中间件（ApiGateway）采用了neo4j-graphql，但其仍有许多不完善之处。

### 高效的schema表达

标准graphql不支持继承等高阶面向对象语义，导致编写schema时需大量重复父类字段。
graphql-s2s项目提供了graphql语法扩展，支持`inherit`等关键字以省略父类字段。其会根据输入的扩展语法schema，生成出标准graphql的schema。因此，我们采用该库转译生成标准语法的schema，再提供给neo4j-graphql。如下例所示。

```graphql
"扩展语法表示"
type Teacher implements FacultyBase & PersonBase inherits Faculty {
    "职称"
    title: ProfessionalTitle
    "classes the teacher teaches"
    classes: [Class!]! @relationship(type:"Teaches", direction:OUT)
    "所指导班级"
    adminClasses: [AdminClass!]! @relationship(type:"HeadOf", direction:OUT)

    "research interests"
    interests: [String!]!
    "research teams"
    teams: [ResearchTeam!]! @relationship(type:"MemberOf", direction:OUT)
}
......
"生成标准语法表示"
type Teacher implements FacultyBase& PersonBase& Entity { 
    "职称"
    title: ProfessionalTitle
    "classes the teacher teaches"
    classes: [Class!]! @relationship(type:"Teaches", direction:OUT)
    "所指导班级"
    adminClasses: [AdminClass!]! @relationship(type:"HeadOf", direction:OUT)
    "research interests"
    interests: [String!]!
    "research teams"
    teams: [ResearchTeam!]! @relationship(type:"MemberOf", direction:OUT)
    "faculty id"
    id: String! @unique
    "职务"
    duties: [Duty!]! @relationship(type:"OnBusiness", direction:OUT)
    name: String!
    birth: Date
    age: Int @customResolver(requires: "birth")
    "biogender, 0 for male, 1 for female"
    gender: Boolean
    "system internal id"
    _id: ID @id
}
```

然而，该库的实现存在诸多问题，我们对此进行了修复。
- 首先，其对schema文本的解析是基于正则表达式而非完善的语法解析器，导致其对`@cypher directive`等中的多行字符串解析出错。对此，我们通过二次字符串替换，将这些出错部分的多行字符串拆解至外部。graphql-s2s接受的文本中以`$filter`等进行占位，转译后由于其仍出于相应位置，在转译结果字符串中再次进行替换即得到完整的标准graphql文本。
- 其次，其对多继承（多个implements项）的实现不符合标准语法。标准中多个interface之间以`&`连接而其以`,`连接。对此，我们fork并修正了该库中的错误，在包管理中依赖我们私有的版本，并也向上游推送了该错误修复。

### 访问权限控制

权限控制是信息平台的核心需求之一。如对于每条Post用户可控制其可被谁看见，包括同学、校友、老师、公开等。

neo4j-graphql提供了`@authorization`等装饰器以描述权限信息，但其是基于查询的因而难以表达我们的复杂需求。对此，我们将要求转换为规则，并通过多个查询条件的与、或组合来表达。例如，同学可见规则表达为
```graphql
{where:{AND:[{node:{user:{realpersonConnection:{node:{_on:{Student:{adminClass:{students_SOME:{name:$id}}}}}}}}},
{node:{policy:"Classmates"}}]}},
```
即，若发帖身份对应的真实用户的班级中含有浏览者，且该帖采用了同学可见策略，则予以通过。

### 复杂字段

由于neo4j-graphql仍处于初期，部分需求难以直接表达。对此，我们也使用了其高级自定义能力。

例如，其无法自动生成interface的所有实例的访问接口，而我们的课程浏览需要该能力，因此我们定义了`CourseKinds`枚举类，并实现了相应的cypher查询语句判定类标签属于`['GeneralCourse', 'DepartmentCourse', 'PECourse']`之一。

例如，某些字段如年龄应在查询时动态计算，为此我们定义了`age`字段的自定义解析器，依赖给定的`birth`字段值，在查询时动态计算当前时刻的年龄。

## 上传控件的自动渲染

## 信息展示的泛型

# 系统测试

## 测试方法

## 具体测试方案

## 典型测试用例

## 测试结论

# 结论

## 总结

## 改进方向

# 附录

## 开发文档

## 源程序

## 标准

## 其他